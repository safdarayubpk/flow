# Implementation Plan: 003-ai-todo-chatbot

**Feature**: Phase III AI-Powered Todo Chatbot
**Created**: 2026-01-23
**Status**: Draft
**Input**: specs/003-ai-todo-chatbot/spec.md

## Technical Context

### Architecture Overview
- **Frontend**: OpenAI ChatKit UI integrated with existing Next.js application
- **Backend**: Python FastAPI API with OpenAI Agents SDK integration
- **AI Logic**: OpenAI Agents SDK for natural language processing
- **Tool Integration**: MCP (Model Context Protocol) server with official SDK
- **Database**: Neon PostgreSQL with SQLModel ORM (existing from Phase II)
- **Authentication**: JWT tokens via Better Auth (existing from Phase II)
- **Deployment**: Vercel (frontend), self-hosted backend (consistent with Phase II)

### Technology Stack
- **AI/Agents**: OpenAI Agents SDK for conversational AI logic
- **MCP**: Official MCP SDK for tool integration
- **Frontend**: OpenAI ChatKit with existing Next.js/TypeScript stack
- **Backend**: FastAPI with existing SQLModel, Pydantic patterns
- **Database**: Neon PostgreSQL (extension of existing schema)
- **Authentication**: Better Auth JWT integration (reuse existing)

### Component Boundaries
- **MCP Server**: Standalone service exposing task operations as tools
- **AI Agent**: OpenAI Agent SDK instance that calls MCP tools
- **Chat API**: FastAPI endpoint orchestrating conversation flow
- **Data Layer**: Existing SQLModel models extended with Conversation/Message entities
- **Frontend**: ChatKit component integrated into existing Next.js app

### Data Flow
1. User sends natural language command via ChatKit frontend
2. Frontend calls backend chat endpoint with JWT authentication
3. Backend fetches conversation history from database
4. OpenAI Agent processes user input and calls appropriate MCP tools
5. MCP tools perform database operations on behalf of the agent
6. Agent generates response based on tool results
7. Backend saves user and assistant messages to database
8. Response is returned to frontend for display

## Constitution Check

### Spec-Driven Development Compliance ✓
- Plan based on existing feature specification in specs/003-ai-todo-chatbot/spec.md
- Architecture decisions documented before implementation
- Reusable components emphasized per constitution

### AI-Only Implementation Compliance ✓
- All code will be generated by Claude Code following SDD workflow
- No manual code modifications permitted per constitution
- Implementation will proceed via /sp.tasks and /sp.implement commands

### Iterative Evolution Compliance ✓
- Builds upon existing Phase I (console) and Phase II (full-stack) foundations
- Maintains backward compatibility with existing API endpoints
- Extends existing data models rather than replacing them

### Reusability and Modularity Compliance ✓
- MCP tools designed as reusable components
- Service layer patterns consistent with existing codebase
- Agent skills potentially reusable for future AI features

### Security and Isolation Compliance ✓
- All operations will respect existing user isolation patterns
- JWT authentication will be validated for all chat endpoints
- MCP tools will include user validation to prevent cross-user access

### Cloud-Native Readiness Compliance ✓
- Architecture supports containerization with Docker
- State management designed for horizontal scaling
- Components loosely coupled for independent deployment

## Research Findings

### OpenAI Agents SDK Integration
- Decision: Use OpenAI Assistants API as the primary agent technology
- Rationale: Better integration with existing OpenAI ecosystem, supports tool calling
- Alternatives considered: LangChain agents, custom prompt engineering

### MCP Server Implementation
- Decision: Implement MCP server using official Python SDK
- Rationale: Standardized protocol for tool integration, future-proof
- Alternatives considered: Direct API calls, custom tool protocol

### Frontend Chat Interface
- Decision: Use OpenAI ChatKit for frontend component
- Rationale: Professional chat interface, reduces custom UI development
- Alternatives considered: Custom React chat component, third-party chat libraries

## Phase 0: Data Modeling

### New Database Entities

#### Conversation Model
- **Fields**:
  - id: Integer (primary key, auto-increment)
  - user_id: String (foreign key to users table, required)
  - created_at: DateTime (timestamp, required, default now)
  - updated_at: DateTime (timestamp, required, default now)
- **Relationships**: Belongs to User, has many Messages
- **Constraints**: Indexed by user_id for efficient querying

#### Message Model
- **Fields**:
  - id: Integer (primary key, auto-increment)
  - conversation_id: Integer (foreign key to conversations table, required)
  - user_id: String (foreign key to users table, required, for validation)
  - role: String (enum: "user", "assistant", required)
  - content: Text (message content, required)
  - created_at: DateTime (timestamp, required, default now)
- **Relationships**: Belongs to Conversation and User
- **Constraints**: Indexed by conversation_id for efficient querying

### Extended Relations
- **User** → **Conversations** (one-to-many)
- **Conversation** → **Messages** (one-to-many)

## Phase 1: API Design

### New API Endpoints

#### Chat Endpoint
- **Method**: POST
- **Path**: `/api/v1/chat`
- **Auth**: JWT token required
- **Request Body**:
  ```json
  {
    "conversation_id": "integer (optional)",
    "message": "string (required)"
  }
  ```
- **Response**:
  ```json
  {
    "conversation_id": "integer",
    "response": "string",
    "tool_calls": "array (optional)"
  }
  ```
- **Function**: Process user message, maintain conversation context, return AI response

#### Conversation Management Endpoints
- **GET** `/api/v1/conversations` - List user's conversations
- **GET** `/api/v1/conversations/{id}` - Get specific conversation details
- **DELETE** `/api/v1/conversations/{id}` - Delete conversation (soft delete)

### Modified Existing Endpoints
- All existing task endpoints maintain current authentication and user isolation

## Phase 2: Implementation Architecture

### Backend Structure
```
backend/
├── src/
│   ├── models/
│   │   ├── conversation.py (new)
│   │   ├── message.py (new)
│   │   └── __init__.py (updated)
│   ├── services/
│   │   ├── conversation_service.py (new)
│   │   └── message_service.py (new)
│   ├── api/
│   │   └── v1/
│   │       ├── chat.py (new)
│   │       └── __init__.py (updated)
│   ├── mcp_server/ (new directory)
│   │   ├── server.py
│   │   ├── tools.py
│   │   └── __init__.py
│   ├── core/
│   │   ├── agents.py (new)
│   │   └── __init__.py
│   └── main.py (updated)
├── requirements.txt (updated)
└── alembic/ (migration files for new models)
```

### Frontend Structure
```
frontend/
├── src/
│   ├── components/
│   │   └── ChatInterface.tsx (new)
│   ├── app/
│   │   └── chat/
│   │       └── page.tsx (new)
│   └── lib/
│       └── api.ts (updated)
├── package.json (updated)
└── README.md (updated)
```

### MCP Tool Specifications

#### add_task Tool
- **Name**: `add_task`
- **Description**: Create a new task for the authenticated user
- **Parameters**:
  - `user_id`: string (required)
  - `title`: string (required)
  - `description`: string (optional)
- **Returns**: Object with task_id, status, and title

#### list_tasks Tool
- **Name**: `list_tasks`
- **Description**: Retrieve tasks for the authenticated user
- **Parameters**:
  - `user_id`: string (required)
  - `status`: string (optional, enum: "all", "pending", "completed")
- **Returns**: Array of task objects

#### complete_task Tool
- **Name**: `complete_task`
- **Description**: Mark a task as complete
- **Parameters**:
  - `user_id`: string (required)
  - `task_id`: integer (required)
- **Returns**: Object with task_id, status, and title

#### delete_task Tool
- **Name**: `delete_task`
- **Description**: Remove a task from the user's list
- **Parameters**:
  - `user_id`: string (required)
  - `task_id`: integer (required)
- **Returns**: Object with task_id, status, and title

#### update_task Tool
- **Name**: `update_task`
- **Description**: Modify task details
- **Parameters**:
  - `user_id`: string (required)
  - `task_id`: integer (required)
  - `title`: string (optional)
  - `description`: string (optional)
- **Returns**: Object with task_id, status, and title

## Phase 3: Integration Points

### Authentication Integration
- JWT tokens from Better Auth will be validated for all chat endpoints
- User ID extracted from token will be passed to MCP tools for validation
- Conversation and message operations will include user validation

### Existing Service Integration
- MCP tools will leverage existing TaskService and UserService
- User isolation patterns from Phase II will be maintained
- Database transaction patterns will be consistent with existing code

## Phase 4: Deployment Considerations

### Local Development
- MCP server can run alongside main FastAPI application
- ChatKit frontend will connect to local backend endpoints
- Authentication flow remains unchanged

### Production Deployment
- MCP server may run as separate service or integrated with main API
- Database migrations will be applied to production schema
- ChatKit domain configuration required for production deployment

## Success Criteria

### Technical Achievement
- [ ] MCP server properly exposes all required tools
- [ ] OpenAI Agent successfully calls MCP tools based on user input
- [ ] Conversation context maintained across multiple exchanges
- [ ] User isolation enforced at all levels (API, MCP, database)
- [ ] Frontend ChatKit properly integrated with backend API
- [ ] Authentication tokens properly validated and propagated

### Functional Achievement
- [ ] Natural language commands correctly mapped to task operations
- [ ] Multi-turn conversations maintain proper context
- [ ] All Phase II functionality remains intact
- [ ] Error handling provides helpful feedback to users
- [ ] Performance acceptable for real-time interaction